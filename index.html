<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Viral QR Code</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #121212;
      /* font-family: monospace; */
      color: #00FF00;
    }
    canvas {
      image-rendering: pixelated;
      border: none;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/base-58@0.0.1/Base58.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
</head>
<body>
  <canvas id="bitmap"></canvas>
  <script>

    function buildNFTMetadata(callback) {
      const storageKey = 'kioskId';

      function getOrCreateKioskId() {
        let id = localStorage.getItem(storageKey);
        if (!id) {
          id = Math.random().toString(36).substring(2, 6).toUpperCase();
          localStorage.setItem(storageKey, id);
        }
        return "kiosk-" + id;
      }

      const fingerprint = {
        dt: new Date().toISOString(),
        tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
        kid: getOrCreateKioskId()
      };

      // Attempt to add location data
      if (!navigator.geolocation) {
        return callback(createMetadata(fingerprint, null));
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const location = {
            lat: +pos.coords.latitude.toFixed(4),
            lon: +pos.coords.longitude.toFixed(4),
            acc: Math.round(pos.coords.accuracy)
          };
          callback(createMetadata(fingerprint, location));
        },
        () => callback(createMetadata(fingerprint, null)),
        { maximumAge: 30000, timeout: 5000 }
      );


      function createMetadata(fp, loc) {
        return {
          name: `Fingerprint for the current kiosk session`,
          description: "A unique browser fingerprint generated by a kiosk device.",
          external_url: `${window.location.origin}`,
          attributes: [
            { trait_type: "Timezone", value: fp.tz },
            { trait_type: "Timestamp", value: fp.dt },
            { trait_type: "Kiosk ID", value: fp.kid },
            ...(loc ? [
              { trait_type: "Latitude", value: loc.lat },
              { trait_type: "Longitude", value: loc.lon },
              { trait_type: "Accuracy (m)", value: loc.acc }
            ] : [])
          ]
        };
      }
    }
    
    class QRCodeRenderer {
      constructor(canvas, data, options = {}) {
        this.canvas = canvas;
        this.data = data;
        this.options = options;
      }
    
      render(callback) {
        QRCode.toCanvas(this.canvas, this.data, this.options, (err) => {
          if (err) console.error(err);
          else if (callback) callback();
        });
      }
    
      async download() {
        // Convert canvas to blob and compute SHA-256 hash for filename
        this.canvas.toBlob(async (blob) => {
          if (blob) {
        const buffer = await blob.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
        const link = document.createElement("a");
        link.download = `viralqrcode-${hashHex}.png`;
        link.href = URL.createObjectURL(blob);
        link.click();
        // Optional: revoke object URL after download
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);
          }
        }, "image/png");
      }
    }

    class ImageBackgroundQRCodeRenderer extends QRCodeRenderer {
      constructor(canvas, data, imageUrl, options = {}) {
        super(canvas, data, options);
        this.imageUrl = imageUrl;
      }

      render(callback) {
        const ctx = this.canvas.getContext("2d");
        const img = new Image();
        img.crossOrigin = "anonymous"; // prevent CORS tainting (optional but recommended)
        img.src = this.imageUrl;

        img.onload = () => {
          // const maxCanvasSize = 1024;
          const maxCanvasSize = 512; // 512px for smaller QR codes
          const imgAspect = img.width / img.height;
          let width, height;

          if (imgAspect >= 1) {
            width = maxCanvasSize;
            height = maxCanvasSize / imgAspect;
          } else {
            height = maxCanvasSize;
            width = maxCanvasSize * imgAspect;
          }

          this.canvas.width = width;
          this.canvas.height = height;
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;

          // Only draw the shadow, not the colored QR code itself
          // Draw background color
          ctx.fillStyle = "#121212";
          ctx.fillRect(0, 0, width, height);
          
          // Draw background image at full opacity
          ctx.globalAlpha = 1.0;
          ctx.drawImage(img, 0, 0, width, height);
          
          // Draw QR code shadow only
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = width;
          tempCanvas.height = height;
          
          QRCode.toCanvas(tempCanvas, this.data, {
            ...this.options,
            width: width,
            color: {
              dark: "#000000bb", // semi-transparent black for shadow
              light: "#00000000"
            }
          }, (err) => {
            if (err) {
              // fallback as before
              console.warn("QR code too large or error occurred, falling back to rendering a QR code for the current URL instead.");
              QRCode.toCanvas(this.canvas, window.location.origin, {
                margin: 2,
                color: { dark: "#00FF00", light: "#121212" }
              });
              hideSpinner();
              return;
            }
            ctx.save();
            ctx.globalAlpha = 0.5;
            ctx.shadowColor = "#000";
            ctx.shadowBlur = 16;
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
            if (callback) callback();
          });
        };

        img.onerror = () => {
          // Just fallback to plain QR code, no error message or alert
          new QRCodeRenderer(this.canvas, this.data, {
            margin: 2,
            color: {
              dark: "#00FF00",
              light: "#121212"
            }
          }).render(() => {
            // Remove any previous click handler
            this.canvas.onclick = null;
            // Secret download: only on click
            this.canvas.onclick = () => this.download();
            if (typeof callback === "function") callback();
          });
        };
      }

      // Override download to avoid tainting: render QR code on a fresh canvas (no background)
      async download() {
        // Create a fresh canvas (same size as main canvas)
        const width = this.canvas.width;
        const height = this.canvas.height;
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;

        // Render QR code only (no background image)
        QRCode.toCanvas(tempCanvas, this.data, {
          ...this.options,
          width: width,
          color: {
            dark: '#00FF00',
            light: '#121212'
          }
        }, async (err) => {
          if (err) {
            console.error(err);
            return;
          }
          tempCanvas.toBlob(async (blob) => {
            if (blob) {
              const buffer = await blob.arrayBuffer();
              const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
              const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
              const link = document.createElement("a");
              link.download = `viralqrcode-${hashHex}.png`;
              link.href = URL.createObjectURL(blob);
              link.click();
              setTimeout(() => URL.revokeObjectURL(link.href), 1000);
            }
          }, "image/png");
        });
      }
    }

    // Recursively decode the 'data' parameter from a URL, following external_url chains
    async function recursiveDecodeData(dataParam, genTracker = { nextGeneration: 0 }) {
      let decodedData = null;
      let currentData = dataParam;
      let depth = 0;
      while (currentData && depth < 10) { // Prevent infinite loops
        try {
          // Step 1: base58 decode, then pako inflate
          const decoded = Base58.decode(currentData);
          const inflated = pako.inflate(decoded, { to: 'string' });
          decodedData = inflated;
          if (depth === 0) {
          console.log("Current Decoded Data:", decodedData);
          }

          // Step 2: parse JSON
          const json = JSON.parse(inflated);
    
          if (json && typeof json === "object") {
            // --- Track nextGeneration at each level ---
            if (Array.isArray(json.attributes)) {
              const generationAttr = json.attributes.find(attr => attr.trait_type === "Generation");
              if (generationAttr) {
                const gen = parseInt(generationAttr.value, 10);
                if (!isNaN(gen) && gen + 1 > genTracker.nextGeneration) {
                  genTracker.nextGeneration = gen + 1;
                }
              } else if (genTracker.nextGeneration < 1) {
                genTracker.nextGeneration = 1;
              }
            }
            // ------------------------------------------
          
            // Defensive: only follow if json has external_url
            if (json.external_url) {
              const url = new URL(json.external_url, window.location.origin);
              const nextData = url.searchParams.get('data');
              if (nextData && nextData !== currentData) {
                currentData = nextData;
                depth++;
              } else {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
        } catch (e) {
          console.error("Failed to recursively decode data:", e);
          break;
        }
      }
      console.log("Deepest Decoded Data:", decodedData);
      return decodedData;
    }

    // Spinner overlay helpers
    function showSpinner(msg = "Loading...") {
      let spinner = document.getElementById("spinner-overlay");
      if (!spinner) {
        spinner = document.createElement("div");
        spinner.id = "spinner-overlay";
        spinner.style.position = "fixed";
        spinner.style.top = 0;
        spinner.style.left = 0;
        spinner.style.width = "100vw";
        spinner.style.height = "100vh";
        spinner.style.background = "rgba(18,18,18,0.92)";
        spinner.style.display = "flex";
        spinner.style.flexDirection = "column";
        spinner.style.justifyContent = "center";
        spinner.style.alignItems = "center";
        spinner.style.zIndex = 9999;
        spinner.innerHTML = `
          <div style="border: 6px solid #222; border-top: 6px solid #00FF00; border-radius: 50%; width: 48px; height: 48px; animation: spin 1s linear infinite;"></div>
          <div style="margin-top: 18px; color: #00FF00; font-family: monospace; font-size: 1.1em;">${msg}</div>
          <style>
            @keyframes spin { 100% { transform: rotate(360deg); } }
          </style>
        `;
        document.body.appendChild(spinner);
      } else {
        spinner.querySelector("div:nth-child(2)").textContent = msg;
        spinner.style.display = "flex";
      }
    }
    function hideSpinner() {
      const spinner = document.getElementById("spinner-overlay");
      if (spinner) spinner.style.display = "none";
    }

     // Fetch latest Reddit story before a given timestamp (same day)
    async function findLatestRedditStoryBefore(timestamp) {
      const res = await fetch("https://www.reddit.com/r/news/new.json?limit=100");
      const data = await res.json();
      const targetDate = new Date(timestamp * 1000).toISOString().slice(0, 10);
      let best = null;
      for (const post of data.data.children) {
        const postTime = post.data.created_utc;
        const postDate = new Date(postTime * 1000).toISOString().slice(0, 10);
        if (postDate !== targetDate) continue;
        if (postTime <= timestamp) {
          if (!best || postTime > best.data.created_utc) best = post;
        }
      }
      return best ? {
        title: best.data.title,
        url: "https://reddit.com" + best.data.permalink,
        id: best.data.id
      } : null;
    }

    async function encryptWithStringKey(password, plaintextBytes) {
      const encoder = new TextEncoder();
      const keyMaterial = encoder.encode(password);

      const passwordKey = await crypto.subtle.importKey(
        "raw", keyMaterial, "PBKDF2", false, ["deriveKey"]
      );

      const salt = crypto.getRandomValues(new Uint8Array(16));
      const derivedKey = await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
        passwordKey,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );

      const iv = crypto.getRandomValues(new Uint8Array(12));

      const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        derivedKey,
        plaintextBytes
      );

      return {
        iv: Array.from(iv),
        salt: Array.from(salt),
        ciphertext: Array.from(new Uint8Array(ciphertext))
      };
    }

    // Function to generate the QR code
    /**
     * Generates a QR code with the current kiosk metadata and data from URL parameters.
     * The QR code will be rendered on a canvas element and can be downloaded by clicking it.
     */
    function generateQRCode() {
      showSpinner("Generating QR Code...");
      const canvas = document.getElementById("bitmap");

      // Remove any previous click listeners to avoid stacking
      canvas.onclick = null;
    
      // Use an async IIFE to await the recursive decode
      (async () => {
        // Build the NFT metadata
        buildNFTMetadata(async (metadata) => {
          const params = new URLSearchParams(window.location.search);
          const data = params.get('data');
          const genTracker = { nextGeneration: 1 };
          const decodedData = await recursiveDecodeData(data, genTracker);
          
          if (decodedData) {
            try {
              const decodedJson = JSON.parse(decodedData);
              if (decodedJson && typeof decodedJson === "object") {
                if (decodedJson.image && decodedJson.image.startsWith("ipfs://")) {
                  metadata.image = decodedJson.image;
                }
                // Use the tracked nextGeneration from all levels
                metadata.attributes = metadata.attributes.filter(attr => attr.trait_type !== "Generation");
                metadata.attributes.push({ trait_type: "Generation", value: genTracker.nextGeneration });
              }
            } catch (e) {
              console.error("Failed to parse decoded 'data' parameter:", e);
            }
          }
          
          const tsAttr = metadata.attributes.find(attr => attr.trait_type === "Timestamp");
          let redditStory = null;
          if (tsAttr && tsAttr.value) {
            const ts = Math.floor(new Date(tsAttr.value).getTime() / 1000);
            redditStory = await findLatestRedditStoryBefore(ts);
          }
          if (redditStory) {
            // --- Encrypt fingerprint attributes with Reddit Story ID as password ---
            const fingerprintTraits = [
              "Timezone",
              "Kiosk ID",
              "Latitude",
              "Longitude",
              "Accuracy (m)"
            ];
            // Extract and remove fingerprint attributes
            const fingerprintAttrs = metadata.attributes.filter(attr => fingerprintTraits.includes(attr.trait_type));
            metadata.attributes = metadata.attributes.filter(attr => !fingerprintTraits.includes(attr.trait_type));
            // Prepare plaintext (as JSON)
            const plaintext = JSON.stringify(fingerprintAttrs);
            const encoder = new TextEncoder();
            const plaintextBytes = encoder.encode(plaintext);
            // Encrypt using Reddit Story ID
            const encrypted = await encryptWithStringKey(redditStory.title, plaintextBytes);
            // Add encrypted attributes to metadata
            metadata.attributes.push(
              { trait_type: "Encrypted Fingerprint", value: JSON.stringify(encrypted.ciphertext) },
              { trait_type: "IV", value: JSON.stringify(encrypted.iv) },
              { trait_type: "Salt", value: JSON.stringify(encrypted.salt) }
            );
            // Add Reddit story attributes as before
            metadata.attributes.push(
              { trait_type: "Event", value: redditStory.title },
            );
          }

          // Re-encode the decodedData as base58 for the external_url
          let parentJsonString = typeof decodedData === "string" ? decodedData : JSON.stringify(decodedData, null, 2);
          // Compress the parent JSON string
          let parentCompressed = pako.deflate(parentJsonString);
          // Encode the compressed data to base58
          let parentBase58 = Base58.encode(parentCompressed);
          // Set the external_url to point to the current page with the encoded data
          metadata.external_url = `${window.location.origin}?data=${encodeURIComponent(parentBase58)}`;
        
          console.log("Data To Be Encoded:", JSON.stringify(metadata, null, 2));   
     
          // Create the payload
          let jsonString = JSON.stringify(metadata, null, 2);
          let compressed = pako.deflate(jsonString);
          let base58 = Base58.encode(compressed);
          let payload = `${window.location.origin}?data=${encodeURIComponent(base58)}`;
          console.log("QR Code Data:", payload);
        
          let imageUrl = null;
          // Replace "ipfs://" with "https://ipfs.io/ipfs/"
          if (metadata.image && metadata.image.startsWith("ipfs://")) {
            imageUrl = metadata.image.replace("ipfs://", "https://ipfs.io/ipfs/");
          }
          console.log("Image URL:", imageUrl);
        
          // Render the QR code with the payload
          function renderQR(dataToUse) {
            const qr = !imageUrl
              ? new QRCodeRenderer(canvas, dataToUse, {
                  margin: 2,
                  color: { dark: "#00FF00", light: "#121212" }
                })
              : new ImageBackgroundQRCodeRenderer(
                  canvas,
                  dataToUse,
                  imageUrl,
                  {
                    margin: 2,
                    color: { dark: "#00FF0077", light: "#00000000" }
                  }
                );
            qr.render(() => {
              canvas.onclick = () => qr.download();
              hideSpinner();
            });
          }
        
          renderQR(payload);
        });
      })();
    }

    window.onload = () => {
      console.log(`Privacy Notice:
This system gathers the following details to create a unique QR code for your session:
- Date, time, and time zone
- Persistent kiosk ID (stored in browser)
- Source URL
- Approximate location (only if permitted)`
      );
      generateQRCode();
    };
  </script>
</body>
</html>

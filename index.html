<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Viral QR Code</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #121212;
      font-family: monospace;
      color: #00FF00;
    }
    canvas {
      image-rendering: pixelated;
      border: none;
    }
    #privacyModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(18, 18, 18, 0.97);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .modal-content {
      max-width: 600px;
      padding: 2rem;
      background-color: #121212;
      border: 1px solid #00FF00;
      text-align: left;
      box-shadow: 0 0 20px #00FF00;
      color: #00FF00;
    }
    .modal-content h2 {
      margin-top: 0;
    }
    .modal-content ul {
      padding-left: 1.2em;
    }
    .modal-content button {
      margin-top: 2rem;
      padding: 0.5rem 1rem;
      background-color: #00FF00;
      color: #121212;
      font-weight: bold;
      font-family: monospace;
      border: none;
      cursor: pointer;
    }
    .modal-content button:hover {
      background-color: #33FF33;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/base-58@0.0.1/Base58.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
</head>
<body>

  <div id="privacyModal">
    <div class="modal-content">
      <h2>Privacy Notice</h2>
      <p>This system gathers the following details to create a unique QR code for your session:</p>
      <ul>
        <li>Browser and OS details</li>
        <li>Date, time, and time zone</li>
        <li>Device specs (memory, CPU cores)</li>
        <li>Persistent kiosk ID (stored in browser)</li>
        <li>Source URL</li>
        <li>Approximate location (if permitted)</li>
      </ul>
      <button onclick="closeModalAndGenerate()">Accept & Continue</button>
    </div>
  </div>

  <canvas id="bitmap"></canvas>

  <script>
    function closeModalAndGenerate() {
      document.getElementById('privacyModal').style.display = 'none';
      generateQRCode();
    }

    function getKioskId() {
      const storageKey = 'kioskId';
      let id = localStorage.getItem(storageKey);
      console.log("Kiosk ID from localStorage:", id);
      // If no ID exists, generate a new one and store it
      if (!id) {
        id = Math.random().toString(36).substring(2, 6).toUpperCase();
        console.log("Generated new Kiosk ID:", id);
        localStorage.setItem(storageKey, id);
      }
      return id;
    }

    function getClientFingerprint() {
      return {
        ua: navigator.userAgent,
        plat: navigator.platform,
        cores: navigator.hardwareConcurrency || null,
        mem: navigator.deviceMemory || null,
        dt: new Date().toISOString(), // e.g. "2025-05-28T14:23:45.123Z",
        tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
        sid: "kiosk-" + getKioskId(),
      };
    }

    function getApproximateLocation(callback) {
      if (!navigator.geolocation) return callback(null);
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          callback({
            lat: +pos.coords.latitude.toFixed(4),
            lon: +pos.coords.longitude.toFixed(4),
            acc: Math.round(pos.coords.accuracy)
          });
        },
        () => callback(null),
        { maximumAge: 30000, timeout: 5000 }
      );
    }
    
    class QRCodeRenderer {
      constructor(canvas, data, options = {}) {
        this.canvas = canvas;
        this.data = data;
        this.options = options;
      }
    
      render(callback) {
        QRCode.toCanvas(this.canvas, this.data, this.options, (err) => {
          if (err) console.error(err);
          else if (callback) callback();
        });
      }
    
      async download() {
        // Convert canvas to blob and compute SHA-256 hash for filename
        this.canvas.toBlob(async (blob) => {
          if (blob) {
        const buffer = await blob.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
        const link = document.createElement("a");
        link.download = `viralqrcode-${hashHex}.png`;
        link.href = URL.createObjectURL(blob);
        link.click();
        // Optional: revoke object URL after download
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);
          }
        }, "image/png");
      }
    }

    class ImageBackgroundQRCodeRenderer extends QRCodeRenderer {
      constructor(canvas, data, imageUrl, options = {}) {
        super(canvas, data, options);
        this.imageUrl = imageUrl;
      }

      render(callback) {
        const ctx = this.canvas.getContext("2d");
        const img = new Image();
        img.crossOrigin = "anonymous"; // prevent CORS tainting (optional but recommended)
        img.src = this.imageUrl;

        img.onload = () => {
          // const maxCanvasSize = 1024;
          const maxCanvasSize = 512; // 512px for smaller QR codes
          const imgAspect = img.width / img.height;
          let width, height;

          if (imgAspect >= 1) {
            width = maxCanvasSize;
            height = maxCanvasSize / imgAspect;
          } else {
            height = maxCanvasSize;
            width = maxCanvasSize * imgAspect;
          }

          this.canvas.width = width;
          this.canvas.height = height;
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;

          // Draw background color
          ctx.fillStyle = "#121212";
          ctx.fillRect(0, 0, width, height);

          // Draw semi-transparent background image
          ctx.globalAlpha = 0.25;
          ctx.drawImage(img, 0, 0, width, height);
          ctx.globalAlpha = 1.0;

          // Draw QR code on top using a temporary canvas
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = width;
          tempCanvas.height = height;

          QRCode.toCanvas(tempCanvas, this.data, {
            ...this.options,
            width: width,
            color: {
              dark: this.options.color?.dark || '#00FF0077',
              light: '#00000000'
            }
          }, (err) => {
            if (err) {
              console.error(err);
            } else {
              ctx.drawImage(tempCanvas, 0, 0);
              if (callback) callback();
            }
          });
        };

        img.onerror = () => {
          // Just fallback to plain QR code, no error message or alert
          new QRCodeRenderer(this.canvas, this.data, {
            margin: 2,
            color: {
              dark: "#00FF00",
              light: "#121212"
            }
          }).render(() => {
            // Remove any previous click handler
            this.canvas.onclick = null;
            // Secret download: only on click
            this.canvas.onclick = () => this.download();
            if (typeof callback === "function") callback();
          });
        };
      }

      // Override download to avoid tainting: render QR code on a fresh canvas (no background)
      async download() {
        // Create a fresh canvas (same size as main canvas)
        const width = this.canvas.width;
        const height = this.canvas.height;
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;

        // Render QR code only (no background image)
        QRCode.toCanvas(tempCanvas, this.data, {
          ...this.options,
          width: width,
          color: {
            dark: '#00FF00',
            light: '#121212'
          }
        }, async (err) => {
          if (err) {
            console.error(err);
            return;
          }
          tempCanvas.toBlob(async (blob) => {
            if (blob) {
              const buffer = await blob.arrayBuffer();
              const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
              const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
              const link = document.createElement("a");
              link.download = `viralqrcode-${hashHex}.png`;
              link.href = URL.createObjectURL(blob);
              link.click();
              setTimeout(() => URL.revokeObjectURL(link.href), 1000);
            }
          }, "image/png");
        });
      }
    }

    async function decodeTopLevelDataUrl(urlOrSearch) {
      if (!urlOrSearch || urlOrSearch === "" || urlOrSearch === "?") return null;

      const search = urlOrSearch.startsWith('?')
        ? urlOrSearch
        : new URL(urlOrSearch).search;
      const params = new URLSearchParams(search);
      const data = params.get('data');
      if (!data) return null;

      try {
        let jsonString;

        // Try Base58 first
        try {
          const decoded = Base58.decode(data);
          jsonString = pako.inflate(decoded, { to: 'string' });
        } catch {
          // Try Base64 fallback
          try {
            if (/^[A-Za-z0-9+/=]+$/.test(data) && data.length % 4 === 0) {
              const decoded = atob(data);
              try {
                jsonString = pako.inflate(Uint8Array.from(decoded, c => c.charCodeAt(0)), { to: 'string' });
              } catch {
                jsonString = decoded;
              }
            } else {
              throw new Error('Not Base64');
            }
          } catch {
            // URI-decoded fallback
            try {
              jsonString = decodeURIComponent(data);
            } catch {
              jsonString = data; // raw string
            }
          }
        }

        return JSON.parse(jsonString);
      } catch (e) {
        console.error("Top-level decode failed:", e);
        return null;
      }
    }

    function findDeepestUrl(nestedJson) {
      if (!nestedJson) return null;
      let obj = typeof nestedJson === 'string' ? JSON.parse(nestedJson) : nestedJson;
      let ref = obj.ref;
      if (!ref) return null;
      if (typeof ref === 'object') {
        return findDeepestUrl(ref);
      }
      if (typeof ref === 'string' && ref.startsWith('http')) {
        return ref;
      }
      return null;
    }

    function generateQRCode() {
      const canvas = document.getElementById("bitmap");

      // Remove any previous click listeners to avoid stacking
      canvas.onclick = null;
    
      // Move these variables to the outer scope of generateQRCode
      let nestedJson = null;
      let imageUrl = null;
    
      // Use an async IIFE to await the recursive decode
      (async () => {
        // 1. Get the nested JSON from the current URL's search/query string
        nestedJson = await decodeTopLevelDataUrl(window.location.search);
    
        // 2. Find the deepest URL (e.g., imageUrl) from the nested JSON
        imageUrl = findDeepestUrl(nestedJson);
    
        console.log("Nested JSON:", nestedJson);
        console.log("Deepest imageUrl:", imageUrl);
    
        // Step 1: Gather fingerprint
        const payload = getClientFingerprint();
        console.log("Payload to be encoded:", payload);
    
        // Step 2: Get location and continue
        getApproximateLocation((loc) => {
          if (loc) payload.loc = loc;
          // If location is not allowed or not available, it will be omitted from the payload
          console.log("Payload with location:", payload);
    
          // Step 2.5: Add nested JSON to payload
          // payload.url = nestedJson || {};
          // Step 2.5: Add nested JSON to payload
          if (nestedJson) {
            payload.ref = nestedJson; // Embed as raw object, not encoded string
          }
          console.log("Payload with nested URL:", payload);
    
          // Step 3: Stringify and encode
          let jsonString = JSON.stringify(payload);
          let compressed = pako.deflate(jsonString);
          let base58 = Base58.encode(compressed);
          let qrData = `${window.location.origin}?data=${encodeURIComponent(base58)}`;
          console.log("QR Code Data:", qrData);
    
          // Try to render the QR code, fallback if it fails
          function renderQR(dataToUse, fallbackTried = false) {
            try {
              const qr = !imageUrl
                ? new QRCodeRenderer(canvas, dataToUse, {
                    margin: 2,
                    color: { dark: "#00FF00", light: "#121212" }
                  })
                : new ImageBackgroundQRCodeRenderer(
                    canvas,
                    dataToUse,
                    imageUrl,
                    {
                      margin: 2,
                      color: { dark: "#00FF0077", light: "#00000000" }
                    }
                  );
              qr.render(() => {
                // Do NOT call qr.download() here!
                // Instead, set up a secret download on click:
                canvas.onclick = () => qr.download();
              });
            } catch (err) {
              if (!fallbackTried) {
                // Fallback: minimal payload
                console.warn("QR code too large or error occurred, falling back to rendering a QR code for the current URL instead.");
                renderQR(window.location.href, true);
              } else {
                // If fallback also fails, log error
                console.error("Failed to render even the minimal QR code:", err);
              }
            }
          }

          renderQR(qrData);
        });
      })();
    }

    window.onload = () => {
      document.getElementById('privacyModal').style.display = 'flex';
    };
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Viral QR Code</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #121212;
      /* font-family: monospace; */
      color: #00FF00;
    }
    canvas {
      image-rendering: pixelated;
      border: none;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/base-58@0.0.1/Base58.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
</head>
<body>
  <canvas id="bitmap"></canvas>
  <script>

    function buildNFTMetadata(callback) {
      const storageKey = 'kioskId';

      function getOrCreateKioskId() {
        let id = localStorage.getItem(storageKey);
        if (!id) {
          id = Math.random().toString(36).substring(2, 6).toUpperCase();
          localStorage.setItem(storageKey, id);
        }
        return "kiosk-" + id;
      }

      const fingerprint = {
        ua: navigator.userAgent,
        plat: navigator.platform,
        cores: navigator.hardwareConcurrency || null,
        mem: navigator.deviceMemory || null,
        dt: new Date().toISOString(),
        tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
        kid: getOrCreateKioskId()
      };

      // Attempt to add location data
      if (!navigator.geolocation) {
        return callback(createMetadata(fingerprint, null));
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const location = {
            lat: +pos.coords.latitude.toFixed(4),
            lon: +pos.coords.longitude.toFixed(4),
            acc: Math.round(pos.coords.accuracy)
          };
          callback(createMetadata(fingerprint, location));
        },
        () => callback(createMetadata(fingerprint, null)),
        { maximumAge: 30000, timeout: 5000 }
      );


      function createMetadata(fp, loc) {
        return {
          name: `Fingerprint for the current kiosk session`,
          description: "A unique browser fingerprint generated by a kiosk device.",
          external_url: `${window.location.origin}`,
          attributes: [
            { trait_type: "User Agent", value: fp.ua },
            { trait_type: "Platform", value: fp.plat },
            { trait_type: "CPU Cores", value: fp.cores },
            { trait_type: "Device Memory (GB)", value: fp.mem },
            { trait_type: "Timezone", value: fp.tz },
            { trait_type: "Timestamp", value: fp.dt },
            { trait_type: "Kiosk ID", value: fp.kid },
            ...(loc ? [
              { trait_type: "Latitude", value: loc.lat },
              { trait_type: "Longitude", value: loc.lon },
              { trait_type: "Accuracy (m)", value: loc.acc }
            ] : [])
          ]
        };
      }
    }
    
    class QRCodeRenderer {
      constructor(canvas, data, options = {}) {
        this.canvas = canvas;
        this.data = data;
        this.options = options;
      }
    
      render(callback) {
        QRCode.toCanvas(this.canvas, this.data, this.options, (err) => {
          if (err) console.error(err);
          else if (callback) callback();
        });
      }
    
      async download() {
        // Convert canvas to blob and compute SHA-256 hash for filename
        this.canvas.toBlob(async (blob) => {
          if (blob) {
        const buffer = await blob.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
        const link = document.createElement("a");
        link.download = `viralqrcode-${hashHex}.png`;
        link.href = URL.createObjectURL(blob);
        link.click();
        // Optional: revoke object URL after download
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);
          }
        }, "image/png");
      }
    }

    class ImageBackgroundQRCodeRenderer extends QRCodeRenderer {
      constructor(canvas, data, imageUrl, options = {}) {
        super(canvas, data, options);
        this.imageUrl = imageUrl;
      }

      render(callback) {
        const ctx = this.canvas.getContext("2d");
        const img = new Image();
        img.crossOrigin = "anonymous"; // prevent CORS tainting (optional but recommended)
        img.src = this.imageUrl;

        img.onload = () => {
          // const maxCanvasSize = 1024;
          const maxCanvasSize = 512; // 512px for smaller QR codes
          const imgAspect = img.width / img.height;
          let width, height;

          if (imgAspect >= 1) {
            width = maxCanvasSize;
            height = maxCanvasSize / imgAspect;
          } else {
            height = maxCanvasSize;
            width = maxCanvasSize * imgAspect;
          }

          this.canvas.width = width;
          this.canvas.height = height;
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;

          // Draw background color
          ctx.fillStyle = "#121212";
          ctx.fillRect(0, 0, width, height);

          // Draw semi-transparent background image
          ctx.globalAlpha = 0.25;
          ctx.drawImage(img, 0, 0, width, height);
          ctx.globalAlpha = 1.0;

          // Draw QR code on top using a temporary canvas
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = width;
          tempCanvas.height = height;

          QRCode.toCanvas(tempCanvas, this.data, {
            ...this.options,
            width: width,
            color: {
              dark: this.options.color?.dark || '#00FF0077',
              light: '#00000000'
            }
          }, (err) => {
            if (err) {
              // Instead of just logging, trigger fallback to minimal payload
              console.warn("QR code too large or error occurred, falling back to rendering a QR code for the current URL instead.");
              QRCode.toCanvas(this.canvas, window.location.origin, {
                margin: 2,
                color: { dark: "#00FF00", light: "#121212" }
              });
              return;
            }
            ctx.drawImage(tempCanvas, 0, 0);
            if (callback) callback();
          });
        };

        img.onerror = () => {
          // Just fallback to plain QR code, no error message or alert
          new QRCodeRenderer(this.canvas, this.data, {
            margin: 2,
            color: {
              dark: "#00FF00",
              light: "#121212"
            }
          }).render(() => {
            // Remove any previous click handler
            this.canvas.onclick = null;
            // Secret download: only on click
            this.canvas.onclick = () => this.download();
            if (typeof callback === "function") callback();
          });
        };
      }

      // Override download to avoid tainting: render QR code on a fresh canvas (no background)
      async download() {
        // Create a fresh canvas (same size as main canvas)
        const width = this.canvas.width;
        const height = this.canvas.height;
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;

        // Render QR code only (no background image)
        QRCode.toCanvas(tempCanvas, this.data, {
          ...this.options,
          width: width,
          color: {
            dark: '#00FF00',
            light: '#121212'
          }
        }, async (err) => {
          if (err) {
            console.error(err);
            return;
          }
          tempCanvas.toBlob(async (blob) => {
            if (blob) {
              const buffer = await blob.arrayBuffer();
              const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
              const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
              const link = document.createElement("a");
              link.download = `viralqrcode-${hashHex}.png`;
              link.href = URL.createObjectURL(blob);
              link.click();
              setTimeout(() => URL.revokeObjectURL(link.href), 1000);
            }
          }, "image/png");
        });
      }
    }
    
    async function decryptWithJsonKey(jsonKeyObj, encryptedData) {
      const decoder = new TextDecoder();
      const encoder = new TextEncoder();
      const jsonString = JSON.stringify(jsonKeyObj);
      const keyMaterial = encoder.encode(jsonString);
    
      const passwordKey = await crypto.subtle.importKey(
        "raw", keyMaterial, "PBKDF2", false, ["deriveKey"]
      );
    
      const salt = new Uint8Array(encryptedData.salt);
      const iv = new Uint8Array(encryptedData.iv);
      const ciphertext = new Uint8Array(encryptedData.ciphertext);
    
      const derivedKey = await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
        passwordKey,
        { name: "AES-GCM", length: 256 },
        true,
        ["decrypt"]
      );
    
      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        derivedKey,
        ciphertext
      );
    
      return new Uint8Array(decrypted);
    }
    
    // Recursive decode + decrypt
    async function recursiveDecodeData(dataParam, getStoryKeyForStep) {
      let decodedData = null;
      let currentData = dataParam;
      let depth = 0;
      showSpinner("Decoding QR data...");
      while (currentData && depth < 10) { // Prevent infinite loops
        try {
          console.log(`[decode] Step ${depth}: base58 decoding...`);
          const decoded = Base58.decode(currentData);
          console.log(`[decode] Step ${depth}: inflating...`);
          const inflated = pako.inflate(decoded, { to: 'string' });
    
          // Try to parse as JSON
          let json;
          try {
            json = JSON.parse(inflated);
            console.log(`[decode] Step ${depth}: parsed JSON`, json);
          } catch {
            json = null;
            console.log(`[decode] Step ${depth}: not JSON`);
          }
    
          // If it looks like an encrypted object, try to decrypt
          if (
            json &&
            typeof json === "object" &&
            json.iv && json.salt && json.ciphertext
          ) {
            showSpinner("Decrypting QR data...");
            console.log(`[decode] Step ${depth}: Detected encrypted payload, fetching story key...`);
            const storyKey = await getStoryKeyForStep(json);
            if (!storyKey) throw new Error("No decryption key for this step");
            console.log(`[decode] Step ${depth}: Decrypting with story key`, storyKey);
            const decryptedBytes = await decryptWithJsonKey(storyKey, json);
            decodedData = pako.inflate(decryptedBytes, { to: 'string' });
            console.log(`[decode] Step ${depth}: Decrypted and inflated`, decodedData);
            try {
              json = JSON.parse(decodedData);
            } catch {
              json = null;
            }
          } else {
            decodedData = inflated;
          }
    
          // Defensive: only follow if json is an object and has external_url
          if (json && typeof json === "object" && json.external_url) {
            const url = new URL(json.external_url, window.location.origin);
            const nextData = url.searchParams.get('data');
            if (nextData && nextData !== currentData) {
              console.log(`[decode] Step ${depth}: Found nested data, recursing...`);
              currentData = nextData;
              depth++;
            } else {
              break;
            }
          } else {
            break;
          }
        } catch (e) {
          console.error("Failed to recursively decode/decrypt data:", e);
          break;
        }
      }
      hideSpinner();
      return decodedData;
    }
    
    // Add this helper at the top of your script (before generateQRCode)
    async function encryptWithJsonKey(jsonKeyObj, plaintextBytes) {
      const encoder = new TextEncoder();
      const jsonString = JSON.stringify(jsonKeyObj);
      const keyMaterial = encoder.encode(jsonString);

      const passwordKey = await crypto.subtle.importKey(
        "raw", keyMaterial, "PBKDF2", false, ["deriveKey"]
      );

      const salt = crypto.getRandomValues(new Uint8Array(16));
      const derivedKey = await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
        passwordKey,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );

      const iv = crypto.getRandomValues(new Uint8Array(12));

      const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        derivedKey,
        plaintextBytes
      );

      return {
        iv: Array.from(iv),
        salt: Array.from(salt),
        ciphertext: Array.from(new Uint8Array(ciphertext))
      };
    }

    // Helper: fetch latest HN story before a given timestamp
    async function findLatestHNStoryBefore(timestamp) {
      const storyIds = await fetch("https://hacker-news.firebaseio.com/v0/newstories.json").then(res => res.json());
      let bestStory = null;
      for (let id of storyIds) {
        const item = await fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`).then(res => res.json());
        if (!item || !item.time || !item.url) continue;
        if (item.time <= timestamp) {
          if (!bestStory || item.time > bestStory.time) {
            bestStory = item;
          }
        }
      }
      return bestStory;
    }

    // Spinner overlay helpers
    function showSpinner(msg = "Loading...") {
      let spinner = document.getElementById("spinner-overlay");
      if (!spinner) {
        spinner = document.createElement("div");
        spinner.id = "spinner-overlay";
        spinner.style.position = "fixed";
        spinner.style.top = 0;
        spinner.style.left = 0;
        spinner.style.width = "100vw";
        spinner.style.height = "100vh";
        spinner.style.background = "rgba(18,18,18,0.92)";
        spinner.style.display = "flex";
        spinner.style.flexDirection = "column";
        spinner.style.justifyContent = "center";
        spinner.style.alignItems = "center";
        spinner.style.zIndex = 9999;
        spinner.innerHTML = `
          <div style="border: 6px solid #222; border-top: 6px solid #00FF00; border-radius: 50%; width: 48px; height: 48px; animation: spin 1s linear infinite;"></div>
          <div style="margin-top: 18px; color: #00FF00; font-family: monospace; font-size: 1.1em;">${msg}</div>
          <style>
            @keyframes spin { 100% { transform: rotate(360deg); } }
          </style>
        `;
        document.body.appendChild(spinner);
      } else {
        spinner.querySelector("div:nth-child(2)").textContent = msg;
        spinner.style.display = "flex";
      }
    }
    function hideSpinner() {
      const spinner = document.getElementById("spinner-overlay");
      if (spinner) spinner.style.display = "none";
    }

    // Function to generate the QR code
    /**
     * Generates a QR code with the current kiosk metadata and data from URL parameters.
     * The QR code will be rendered on a canvas element and can be downloaded by clicking it.
     */
    function generateQRCode() {
      const canvas = document.getElementById("bitmap");
    
      // Remove any previous click listeners to avoid stacking
      canvas.onclick = null;
    
      // Use an async IIFE to await the recursive decode
      (async () => {
        // Build the NFT metadata
        
        buildNFTMetadata(async (metadata) => {
          const params = new URLSearchParams(window.location.search);
          const data = params.get('data');
        
          // Get timestamp from metadata (ISO string to UNIX seconds)
          const tsAttr = metadata.attributes.find(a => a.trait_type === "Timestamp");
          const cutoffTimestamp = tsAttr ? Math.floor(new Date(tsAttr.value).getTime() / 1000) : Math.floor(Date.now() / 1000);
        
          // Prepare the function to get the story key for decryption
          async function getStoryKeyForStep(json) {
            const ts = json.time || cutoffTimestamp;
            showSpinner();
            const hnStory = await findLatestHNStoryBefore(ts);
            hideSpinner();
            if (!hnStory) return null;
            return {
              id: hnStory.id,
              title: hnStory.title,
              url: hnStory.url,
              time: hnStory.time,
              by: hnStory.by
            };
          }
        
          // Now call recursiveDecodeData with both arguments:
          recursiveDecodeData(data, getStoryKeyForStep).then(async decodedData => {
            console.log("[QR] Deepest Decoded Data:", decodedData);

            // Show spinner while processing
            showSpinner("Decrypting and processing data...");
            if (decodedData) {
              try {
                const decodedJson = JSON.parse(decodedData);
                if (decodedJson && typeof decodedJson === "object") {
                  if (decodedJson.image && decodedJson.image.startsWith("ipfs://")) {
                    metadata.image = decodedJson.image;
                  }
                  // Look for a generation attribute
                  let nextGeneration = 0;
                  if (decodedJson.attributes) {
                    const generationAttr = decodedJson.attributes.find(attr => attr.trait_type === "Generation");
                    if (generationAttr) {
                      const prevGen = parseInt(generationAttr.value, 10);
                      nextGeneration = isNaN(prevGen) ? 0 : prevGen + 1;
                    }
                  }
                  metadata.attributes = metadata.attributes.filter(attr => attr.trait_type !== "Generation");
                  metadata.attributes.push({ trait_type: "Generation", value: nextGeneration });
                }
              } catch (e) {
                console.error("Failed to recursively decode/decrypt data:", e);
                if (e instanceof DOMException) {
                  console.error("DOMException name:", e.name, "message:", e.message);
                }
                // Optionally, show a user-friendly message
                showSpinner("Failed to decode or decrypt QR data. Data may be corrupted or key is missing.");
                setTimeout(hideSpinner, 2500);
                return;
              }
            }
            // Hide spinner after processing
            hideSpinner();

            // Get timestamp from metadata (ISO string to UNIX seconds)
            const tsAttr = metadata.attributes.find(a => a.trait_type === "Timestamp");
            const cutoffTimestamp = tsAttr ? Math.floor(new Date(tsAttr.value).getTime() / 1000) : Math.floor(Date.now() / 1000);
            console.log(`[QR] Using cutoffTimestamp: ${cutoffTimestamp} (${new Date(cutoffTimestamp * 1000).toISOString()})`);
    
            // --- Fetch HN story before timestamp ---
            console.log("[QR] Fetching latest Hacker News story before timestamp...");
            showSpinner();
            const hnStory = await findLatestHNStoryBefore(cutoffTimestamp);
            hideSpinner();
            if (!hnStory) {
              console.warn("[QR] No Hacker News story found before timestamp!");
              alert("No Hacker News story found before timestamp!");
              return;
            }
            const storyKey = {
              id: hnStory.id,
              title: hnStory.title,
              url: hnStory.url,
              time: hnStory.time,
              by: hnStory.by
            };
            console.log("[QR] Using HN story as encryption key:", storyKey);
    
            // --- Symmetric encryption step using HN story as key ---
            showSpinner("Encrypting...");
            let parentJsonString = typeof decodedData === "string" ? decodedData : JSON.stringify(decodedData, null, 2);
            let parentCompressed = pako.deflate(parentJsonString);
            console.log("[QR] Compressed parent data:", parentCompressed);
            console.log("[QR] Encrypting parent data with HN story key...");
            const parentEncryptedObj = await encryptWithJsonKey(storyKey, parentCompressed);
            console.log("[QR] Encrypted parent data:", parentEncryptedObj);
            hideSpinner();
    
            // Optional: Try decrypting right away to verify
            try {
              const decoder = new TextDecoder();
              // Reconstruct key and encrypted data
              const decryptedBuffer = await (async () => {
                // Re-import key and decrypt
                const encoder = new TextEncoder();
                const jsonString = JSON.stringify(storyKey);
                const keyMaterial = encoder.encode(jsonString);
                const passwordKey = await crypto.subtle.importKey(
                  "raw", keyMaterial, "PBKDF2", false, ["deriveKey"]
                );
                const salt = new Uint8Array(parentEncryptedObj.salt);
                const iv = new Uint8Array(parentEncryptedObj.iv);
                const ciphertext = new Uint8Array(parentEncryptedObj.ciphertext);
                const derivedKey = await crypto.subtle.deriveKey(
                  { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
                  passwordKey,
                  { name: "AES-GCM", length: 256 },
                  true,
                  ["decrypt"]
                );
                const decrypted = await crypto.subtle.decrypt(
                  { name: "AES-GCM", iv },
                  derivedKey,
                  ciphertext
                );
                return decrypted;
              })();
              const decompressed = pako.inflate(new Uint8Array(decryptedBuffer), { to: 'string' });
              console.log("[QR] Decrypted and decompressed parent data:", decompressed);
            } catch (e) {
              console.warn("[QR] Decryption test failed:", e);
            }
    
            let parentEncryptedJson = JSON.stringify(parentEncryptedObj);
            let parentEncryptedCompressed = pako.deflate(parentEncryptedJson);
            let parentBase58 = Base58.encode(parentEncryptedCompressed);
    
            // Set the external_url to point to the current page with the encoded data
            metadata.external_url = `${window.location.origin}?data=${encodeURIComponent(parentBase58)}`;
            console.log("[QR] Set metadata.external_url to encrypted parent data.");
    
            console.log("[QR] Metadata for this QR:", metadata);
    
            // Create the payload
            let jsonString = JSON.stringify(metadata, null, 2);
            let compressed = pako.deflate(jsonString);
            let base58 = Base58.encode(compressed);
            let payload = `${window.location.origin}?data=${encodeURIComponent(base58)}`;
            console.log("[QR] Final QR Code Data:", payload);
    
            let imageUrl = null;
            // Replace "ipfs://" with "https://ipfs.io/ipfs/"
            if (metadata.image && metadata.image.startsWith("ipfs://")) {
              imageUrl = metadata.image.replace("ipfs://", "https://ipfs.io/ipfs/");
            }
            if (imageUrl) {
              console.log("[QR] Using image background:", imageUrl);
            }
    
            // Render the QR code with the payload
            function renderQR(dataToUse) {
              const qr = !imageUrl
                ? new QRCodeRenderer(canvas, dataToUse, {
                    margin: 2,
                    color: { dark: "#00FF00", light: "#121212" }
                  })
                : new ImageBackgroundQRCodeRenderer(
                    canvas,
                    dataToUse,
                    imageUrl,
                    {
                      margin: 2,
                      color: { dark: "#00FF0077", light: "#00000000" }
                    }
                  );
              qr.render(() => {
                canvas.onclick = () => qr.download();
              });
            }
    
            renderQR(payload);
          });
        });
      })();
    }

    window.onload = () => {
      console.log(`Privacy Notice:
This system gathers the following details to create a unique QR code for your session:
- Browser and OS details
- Date, time, and time zone
- Device specs (memory, CPU cores)
- Persistent kiosk ID (stored in browser)
- Source URL
- Approximate location (only if permitted)`
      );
      generateQRCode();
    };
  </script>
</body>
</html>

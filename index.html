<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Viral QR Code</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #121212;
      /* font-family: monospace; */
      color: #00FF00;
    }
    canvas {
      image-rendering: pixelated;
      border: none;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/base-58@0.0.1/Base58.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
</head>
<body>
  <canvas id="bitmap"></canvas>
  <script>

    function buildNFTMetadata(callback) {
      const storageKey = 'kioskId';

      function getOrCreateKioskId() {
        let id = localStorage.getItem(storageKey);
        if (!id) {
          id = Math.random().toString(36).substring(2, 6).toUpperCase();
          localStorage.setItem(storageKey, id);
        }
        return "kiosk-" + id;
      }

      const fingerprint = {
        ua: navigator.userAgent,
        plat: navigator.platform,
        cores: navigator.hardwareConcurrency || null,
        mem: navigator.deviceMemory || null,
        dt: new Date().toISOString(),
        tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
        kid: getOrCreateKioskId()
      };

      // Attempt to add location data
      if (!navigator.geolocation) {
        return callback(createMetadata(fingerprint, null));
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const location = {
            lat: +pos.coords.latitude.toFixed(4),
            lon: +pos.coords.longitude.toFixed(4),
            acc: Math.round(pos.coords.accuracy)
          };
          callback(createMetadata(fingerprint, location));
        },
        () => callback(createMetadata(fingerprint, null)),
        { maximumAge: 30000, timeout: 5000 }
      );


      function createMetadata(fp, loc) {
        return {
          name: `Fingerprint for the current kiosk session`,
          description: "A unique browser fingerprint generated by a kiosk device.",
          external_url: `${window.location.origin}`,
          attributes: [
            { trait_type: "User Agent", value: fp.ua },
            { trait_type: "Platform", value: fp.plat },
            { trait_type: "CPU Cores", value: fp.cores },
            { trait_type: "Device Memory (GB)", value: fp.mem },
            { trait_type: "Timezone", value: fp.tz },
            { trait_type: "Timestamp", value: fp.dt },
            { trait_type: "Kiosk ID", value: fp.kid },
            ...(loc ? [
              { trait_type: "Latitude", value: loc.lat },
              { trait_type: "Longitude", value: loc.lon },
              { trait_type: "Accuracy (m)", value: loc.acc }
            ] : [])
          ]
        };
      }
    }
    
    class QRCodeRenderer {
      constructor(canvas, data, options = {}) {
        this.canvas = canvas;
        this.data = data;
        this.options = options;
      }
    
      render(callback) {
        QRCode.toCanvas(this.canvas, this.data, this.options, (err) => {
          if (err) console.error(err);
          else if (callback) callback();
        });
      }
    
      async download() {
        // Convert canvas to blob and compute SHA-256 hash for filename
        this.canvas.toBlob(async (blob) => {
          if (blob) {
        const buffer = await blob.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
        const link = document.createElement("a");
        link.download = `viralqrcode-${hashHex}.png`;
        link.href = URL.createObjectURL(blob);
        link.click();
        // Optional: revoke object URL after download
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);
          }
        }, "image/png");
      }
    }

    class ImageBackgroundQRCodeRenderer extends QRCodeRenderer {
      constructor(canvas, data, imageUrl, options = {}) {
        super(canvas, data, options);
        this.imageUrl = imageUrl;
      }

      render(callback) {
        const ctx = this.canvas.getContext("2d");
        const img = new Image();
        img.crossOrigin = "anonymous"; // prevent CORS tainting (optional but recommended)
        img.src = this.imageUrl;

        img.onload = () => {
          // const maxCanvasSize = 1024;
          const maxCanvasSize = 512; // 512px for smaller QR codes
          const imgAspect = img.width / img.height;
          let width, height;

          if (imgAspect >= 1) {
            width = maxCanvasSize;
            height = maxCanvasSize / imgAspect;
          } else {
            height = maxCanvasSize;
            width = maxCanvasSize * imgAspect;
          }

          this.canvas.width = width;
          this.canvas.height = height;
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;

          // Draw background color
          ctx.fillStyle = "#121212";
          ctx.fillRect(0, 0, width, height);

          // Draw semi-transparent background image
          ctx.globalAlpha = 0.25;
          ctx.drawImage(img, 0, 0, width, height);
          ctx.globalAlpha = 1.0;

          // Draw QR code on top using a temporary canvas
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = width;
          tempCanvas.height = height;

          QRCode.toCanvas(tempCanvas, this.data, {
            ...this.options,
            width: width,
            color: {
              dark: this.options.color?.dark || '#00FF0077',
              light: '#00000000'
            }
          }, (err) => {
            if (err) {
              // Instead of just logging, trigger fallback to minimal payload
              console.warn("QR code too large or error occurred, falling back to rendering a QR code for the current URL instead.");
              QRCode.toCanvas(this.canvas, window.location.origin, {
                margin: 2,
                color: { dark: "#00FF00", light: "#121212" }
              });
              return;
            }
            ctx.drawImage(tempCanvas, 0, 0);
            if (callback) callback();
          });
        };

        img.onerror = () => {
          // Just fallback to plain QR code, no error message or alert
          new QRCodeRenderer(this.canvas, this.data, {
            margin: 2,
            color: {
              dark: "#00FF00",
              light: "#121212"
            }
          }).render(() => {
            // Remove any previous click handler
            this.canvas.onclick = null;
            // Secret download: only on click
            this.canvas.onclick = () => this.download();
            if (typeof callback === "function") callback();
          });
        };
      }

      // Override download to avoid tainting: render QR code on a fresh canvas (no background)
      async download() {
        // Create a fresh canvas (same size as main canvas)
        const width = this.canvas.width;
        const height = this.canvas.height;
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;

        // Render QR code only (no background image)
        QRCode.toCanvas(tempCanvas, this.data, {
          ...this.options,
          width: width,
          color: {
            dark: '#00FF00',
            light: '#121212'
          }
        }, async (err) => {
          if (err) {
            console.error(err);
            return;
          }
          tempCanvas.toBlob(async (blob) => {
            if (blob) {
              const buffer = await blob.arrayBuffer();
              const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
              const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
              const link = document.createElement("a");
              link.download = `viralqrcode-${hashHex}.png`;
              link.href = URL.createObjectURL(blob);
              link.click();
              setTimeout(() => URL.revokeObjectURL(link.href), 1000);
            }
          }, "image/png");
        });
      }
    }

    function generateQRCode() {
      const canvas = document.getElementById("bitmap");

      // Remove any previous click listeners to avoid stacking
      canvas.onclick = null;
    
      // Use an async IIFE to await the recursive decode
      (async () => {
        // Build the NFT metadata
        buildNFTMetadata((metadata) => {
          const params = new URLSearchParams(window.location.search);
          const data = params.get('data');

          // `data` is base58 encoded, decode it
          let decodedData;
          if (data) {
            try {
              const decoded = Base58.decode(data);
              decodedData = pako.inflate(decoded, { to: 'string' });
            } catch (e) {
              console.error("Failed to decode 'data' parameter:", e);
              decodedData = null;
            }
          }
          console.log("Decoded Data:", decodedData);

          // Look for image URL in decoded data and put it in metadata along with generation
          if (decodedData) {
            try {
              const decodedJson = JSON.parse(decodedData);
              if (decodedJson.image && decodedJson.image.startsWith("ipfs://")) {
                metadata.image = decodedJson.image;
              }
              // Look for a generation attribute
              let nextGeneration = 0;
              if (decodedJson.attributes) {
                const generationAttr = decodedJson.attributes.find(attr => attr.trait_type === "Generation");
                if (generationAttr) {
                  // Try to parse as integer and increment
                  const prevGen = parseInt(generationAttr.value, 10);
                  nextGeneration = isNaN(prevGen) ? 0 : prevGen + 1;
                }
              }
              // Add or update the Generation attribute in metadata
              metadata.attributes = metadata.attributes.filter(attr => attr.trait_type !== "Generation");
              metadata.attributes.push({ trait_type: "Generation", value: nextGeneration });
            } catch (e) {
              console.error("Failed to parse decoded 'data' parameter:", e);
            }
          }

          metadata.external_url = `${window.location.origin}?data=${encodeURIComponent(JSON.stringify(decodedData))}`;

          console.log("Metadata:", metadata);

          // Create the payload
          let jsonString = JSON.stringify(metadata, null, 2);
          // Compress the JSON string using pako
          let compressed = pako.deflate(jsonString);
          // Encode the compressed data to Base58
          let base58 = Base58.encode(compressed);
          // Add the base58 encoded data to the metadata
          
          let payload = `${window.location.origin}?data=${encodeURIComponent(base58)}`;
          console.log("QR Code Data:", payload);
          
          let imageUrl = null
          // Replace "ipfs://" with "https://ipfs.io/ipfs/"
          if (metadata.image && metadata.image.startsWith("ipfs://")) {
            imageUrl = metadata.image.replace("ipfs://", "https://ipfs.io/ipfs/");
          }
          console.log("Image URL:", imageUrl);
          
          // Render the QR code with the payload
          function renderQR(dataToUse) {
            const qr = !imageUrl
              ? new QRCodeRenderer(canvas, dataToUse, {
                  margin: 2,
                  color: { dark: "#00FF00", light: "#121212" }
                })
              : new ImageBackgroundQRCodeRenderer(
                  canvas,
                  dataToUse,
                  imageUrl,
                  {
                    margin: 2,
                    color: { dark: "#00FF0077", light: "#00000000" }
                  }
                );
            qr.render(() => {
              canvas.onclick = () => qr.download();
            });
          }

          renderQR(payload);
        });
      })();
    }

    window.onload = () => {
      console.log(`Privacy Notice:
This system gathers the following details to create a unique QR code for your session:
- Browser and OS details
- Date, time, and time zone
- Device specs (memory, CPU cores)
- Persistent kiosk ID (stored in browser)
- Source URL
- Approximate location (only if permitted)`
      );
      generateQRCode();
    };
  </script>
</body>
</html>

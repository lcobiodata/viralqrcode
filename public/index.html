<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Viral QR Code</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #121212;
      /* font-family: monospace; */
      color: #00FF00;
    }
    canvas {
      image-rendering: pixelated;
      border: none;
    }
    #privacy-footer {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100vw;
      text-align: center;
      color: #00FF00;
      font-family: monospace;
      font-size: 1em;
      background: none;
      z-index: 100;
      padding: 12px 0;
    }
    #privacy-footer a {
      color: #00FF00;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/base-58@0.0.1/Base58.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
</head>
<body>
  <canvas id="bitmap"></canvas>
  <script>

    function buildNFTMetadata(callback) {
    
      // --- Use only geolocation (no IP fallback) ---
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const location = {
              lat: +pos.coords.latitude.toFixed(4),
              lon: +pos.coords.longitude.toFixed(4),
              acc: Math.round(pos.coords.accuracy)
            };
            // sendLocation({ ... }, 'gps'); // Optionally comment this out too
            callback(createMetadata(location));
          },
          (error) => {
            // No location available
            callback(createMetadata({}));
          },
          { maximumAge: 30000, timeout: 5000 }
        );
      } else {
        // No location available
        callback(createMetadata({}));
      }
    
      function createMetadata(location) {
        return {
          name: "Anonymous browser fingerprint",
          description: "A unique, ephemeral browser fingerprint generated for this session.",
          external_url: `${window.location.origin}`,
          attributes: [
            { trait_type: "Kiosk ID", value: (() => {
                let id = localStorage.getItem('kioskId');
                if (!id) {
                  id = Math.random().toString(36).substring(2, 6).toUpperCase();
                  localStorage.setItem('kioskId', id);
                }
                return "kiosk-" + id;
              })()
            },
            { trait_type: "Device Type", value: navigator.userAgent },
            { trait_type: "Browser", value: navigator.appName },
            { trait_type: "Platform", value: navigator.platform },
            { trait_type: "User Agent", value: navigator.userAgent },
            { trait_type: "Language", value: navigator.language || navigator.userLanguage },
            { trait_type: "Timestamp", value: new Date().toISOString() },
            { trait_type: "Timezone", value: Intl.DateTimeFormat().resolvedOptions().timeZone },
            { trait_type: "Timezone Offset", value: (new Date().getTimezoneOffset() / -60) + " hours" },
            ...(location.lat !== undefined && location.lon !== undefined && location.acc !== undefined
              ? [
                  { trait_type: "Latitude", value: location.lat },
                  { trait_type: "Longitude", value: location.lon },
                  { trait_type: "Accuracy (m)", value: location.acc }
                ]
              : [])
            // { trait_type: "IP Address", value: location.ip } // Commented out
          ]
        };
      }
    }
    
    class QRCodeRenderer {
      constructor(canvas, data, options = {}) {
        this.canvas = canvas;
        this.data = data;
        this.options = options;
      }
    
      render(callback) {
        QRCode.toCanvas(this.canvas, this.data, this.options, (err) => {
          if (err) console.error(err);
          else if (callback) callback();
        });
      }
    
      async download() {
        // Convert canvas to blob and compute SHA-256 hash for filename
        this.canvas.toBlob(async (blob) => {
          if (blob) {
        const buffer = await blob.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
        const link = document.createElement("a");
        link.download = `viralqrcode-${hashHex}.png`;
        link.href = URL.createObjectURL(blob);
        link.click();
        // Optional: revoke object URL after download
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);
          }
        }, "image/png");
      }
    }

    class ImageBackgroundQRCodeRenderer extends QRCodeRenderer {
      constructor(canvas, data, imageUrl, options = {}) {
        super(canvas, data, options);
        this.imageUrl = imageUrl;
      }

      render(callback) {
        const ctx = this.canvas.getContext("2d");
        const img = new Image();
        img.crossOrigin = "anonymous"; // prevent CORS tainting (optional but recommended)
        img.src = this.imageUrl;

        img.onload = () => {
          // const maxCanvasSize = 1024;
          const maxCanvasSize = 512; // 512px for smaller QR codes
          const imgAspect = img.width / img.height;
          let width, height;

          if (imgAspect >= 1) {
            width = maxCanvasSize;
            height = maxCanvasSize / imgAspect;
          } else {
            height = maxCanvasSize;
            width = maxCanvasSize * imgAspect;
          }

          this.canvas.width = width;
          this.canvas.height = height;
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;

          // Only draw the shadow, not the colored QR code itself
          // Draw background color
          ctx.fillStyle = "#121212";
          ctx.fillRect(0, 0, width, height);
          
          // Draw background image at full opacity
          ctx.globalAlpha = 1.0;
          ctx.drawImage(img, 0, 0, width, height);
          
          // Draw QR code shadow only
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = width;
          tempCanvas.height = height;
          
          QRCode.toCanvas(tempCanvas, this.data, {
            ...this.options,
            width: width,
            color: {
              dark: "#000000bb", // semi-transparent black for shadow
              light: "#00000000"
            }
          }, (err) => {
            if (err) {
              // fallback as before
              console.warn("QR code too large or error occurred, falling back to rendering a QR code for the current URL instead.");
              QRCode.toCanvas(this.canvas, window.location.origin, {
                margin: 2,
                color: { dark: "#00FF00", light: "#121212" }
              });
              hideSpinner();
              return;
            }
            ctx.save();
            ctx.globalAlpha = 0.5;
            ctx.shadowColor = "#000";
            ctx.shadowBlur = 16;
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
            if (callback) callback();
          });
        };

        img.onerror = () => {
          // Just fallback to plain QR code, no error message or alert
          new QRCodeRenderer(this.canvas, this.data, {
            margin: 2,
            color: {
              dark: "#00FF00",
              light: "#121212"
            }
          }).render(() => {
            // Remove any previous click handler
            this.canvas.onclick = null;
            // Secret download: only on click
            this.canvas.onclick = () => this.download();
            if (typeof callback === "function") callback();
          });
        };
      }

      // Override download to avoid tainting: render QR code on a fresh canvas (no background)
      async download() {
        // Create a fresh canvas (same size as main canvas)
        const width = this.canvas.width;
        const height = this.canvas.height;
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;

        // Render QR code only (no background image)
        QRCode.toCanvas(tempCanvas, this.data, {
          ...this.options,
          width: width,
          color: {
            dark: '#00FF00',
            light: '#121212'
          }
        }, async (err) => {
          if (err) {
            console.error(err);
            return;
          }
          tempCanvas.toBlob(async (blob) => {
            if (blob) {
              const buffer = await blob.arrayBuffer();
              const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
              const hashHex = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
              const link = document.createElement("a");
              link.download = `viralqrcode-${hashHex}.png`;
              link.href = URL.createObjectURL(blob);
              link.click();
              setTimeout(() => URL.revokeObjectURL(link.href), 1000);
            }
          }, "image/png");
        });
      }
    }

    // Recursively decode the 'data' parameter from a URL, following external_url chains
    async function recursiveDecodeData(dataParam, genTracker = { nextGeneration: 0 }) {
      let decodedData = null;
      let currentData = dataParam;
      let depth = 0;
      while (currentData && depth < 10) { // Prevent infinite loops
        try {
          // Step 1: base58 decode, then pako inflate
          const decoded = Base58.decode(currentData);
          const inflated = pako.inflate(decoded, { to: 'string' });
          decodedData = inflated;
          if (depth === 0) {
          console.log("Current Decoded Data:", decodedData);
          }

          // Step 2: parse JSON
          const json = JSON.parse(inflated);
    
          if (json && typeof json === "object") {
            // --- Track nextGeneration at each level ---
            if (Array.isArray(json.attributes)) {
              const generationAttr = json.attributes.find(attr => attr.trait_type === "Generation");
              if (generationAttr) {
                const gen = parseInt(generationAttr.value, 10);
                if (!isNaN(gen) && gen + 1 > genTracker.nextGeneration) {
                  genTracker.nextGeneration = gen + 1;
                }
              } else if (genTracker.nextGeneration < 1) {
                genTracker.nextGeneration = 1;
              }
            }
            // ------------------------------------------
          
            // Defensive: only follow if json has external_url
            if (json.external_url) {
              const url = new URL(json.external_url, window.location.origin);
              const nextData = url.searchParams.get('data');
              if (nextData && nextData !== currentData) {
                currentData = nextData;
                depth++;
              } else {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
        } catch (e) {
          console.error("Failed to recursively decode data:", e);
          break;
        }
      }
      console.log("Deepest Decoded Data:", decodedData);
      return decodedData;
    }

    // Spinner overlay helpers
    function showSpinner(msg = "Loading...") {
      let spinner = document.getElementById("spinner-overlay");
      if (!spinner) {
        spinner = document.createElement("div");
        spinner.id = "spinner-overlay";
        spinner.style.position = "fixed";
        spinner.style.top = 0;
        spinner.style.left = 0;
        spinner.style.width = "100vw";
        spinner.style.height = "100vh";
        spinner.style.background = "rgba(18,18,18,0.92)";
        spinner.style.display = "flex";
        spinner.style.flexDirection = "column";
        spinner.style.justifyContent = "center";
        spinner.style.alignItems = "center";
        spinner.style.zIndex = 9999;
        spinner.innerHTML = `
          <div style="border: 6px solid #222; border-top: 6px solid #00FF00; border-radius: 50%; width: 48px; height: 48px; animation: spin 1s linear infinite;"></div>
          <div style="margin-top: 18px; color: #00FF00; font-family: monospace; font-size: 1.1em;">${msg}</div>
          <style>
            @keyframes spin { 100% { transform: rotate(360deg); } }
          </style>
        `;
        document.body.appendChild(spinner);
      } else {
        spinner.querySelector("div:nth-child(2)").textContent = msg;
        spinner.style.display = "flex";
      }
    }
    function hideSpinner() {
      const spinner = document.getElementById("spinner-overlay");
      if (spinner) spinner.style.display = "none";
    }

     // Fetch latest Reddit story before a given timestamp (same day)
    async function preventMandelaEffect(timestamp) {
      const res = await fetch("https://www.reddit.com/r/news/new.json?limit=100");
      const data = await res.json();
      const targetDate = new Date(timestamp * 1000).toISOString().slice(0, 10);
      let best = null;
      for (const post of data.data.children) {
        const postTime = post.data.created_utc;
        const postDate = new Date(postTime * 1000).toISOString().slice(0, 10);
        if (postDate !== targetDate) continue;
        if (postTime <= timestamp) {
          if (!best || postTime > best.data.created_utc) best = post;
        }
      }
      return best ? {
        title: best.data.title,
        url: "https://reddit.com" + best.data.permalink,
        id: best.data.id
      } : null;
    }

    async function encryptWithStringKey(password, plaintextBytes) {
      const encoder = new TextEncoder();
      const keyMaterial = encoder.encode(password);

      const passwordKey = await crypto.subtle.importKey(
        "raw", keyMaterial, "PBKDF2", false, ["deriveKey"]
      );

      const salt = crypto.getRandomValues(new Uint8Array(16));
      const derivedKey = await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
        passwordKey,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );

      const iv = crypto.getRandomValues(new Uint8Array(12));

      const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        derivedKey,
        plaintextBytes
      );

      return {
        iv: Array.from(iv),
        salt: Array.from(salt),
        ciphertext: Array.from(new Uint8Array(ciphertext))
      };
    }

    // Function to generate the QR code
    /**
     * Generates a QR code with the current kiosk metadata and data from URL parameters.
     * The QR code will be rendered on a canvas element and can be downloaded by clicking it.
     */
    function generateQRCode() {
      showSpinner("Generating QR Code...");
      const canvas = document.getElementById("bitmap");

      // Remove any previous click listeners to avoid stacking
      canvas.onclick = null;
    
      // Use an async IIFE to await the recursive decode
      (async () => {
        // Build the NFT metadata
        buildNFTMetadata(async (metadata) => {
          const params = new URLSearchParams(window.location.search);
          const data = params.get('data');
          const genTracker = { nextGeneration: 1 };
          const decodedData = await recursiveDecodeData(data, genTracker);
          
          if (decodedData) {
            try {
              const decodedJson = JSON.parse(decodedData);
              if (decodedJson && typeof decodedJson === "object") {
                if (decodedJson.image && decodedJson.image.startsWith("ipfs://")) {
                  metadata.image = decodedJson.image;
                }
                // Use the tracked nextGeneration from all levels
                metadata.attributes = metadata.attributes.filter(attr => attr.trait_type !== "Generation");
                metadata.attributes.push({ trait_type: "Generation", value: genTracker.nextGeneration });
              }
            } catch (e) {
              console.error("Failed to parse decoded 'data' parameter:", e);
            }
          }
          
          const tsAttr = metadata.attributes.find(attr => attr.trait_type === "Timestamp");
          let mandelaAnchor = null;
          if (tsAttr && tsAttr.value) {
            const ts = Math.floor(new Date(tsAttr.value).getTime() / 1000);
            mandelaAnchor = await preventMandelaEffect(ts);
          }
          if (mandelaAnchor) {
            // Add Reddit story attributes as before
            metadata.attributes.push(
              { trait_type: "Mandela Anchor", value: mandelaAnchor.title },
            );
            // --- Encrypt fingerprint attributes with Reddit Story ID as password ---
            const fingerprintTraits = [
              "Kiosk ID",
              "Device Type",
              "Browser",
              "Platform",
              "User Agent",
              "Screen Resolution",
              "Color Depth",
              "Timezone Offset",
              "Timezone Name",
              "Language",
              "User Agent Language",
              "Timezone",
              "Timestamp",
              "Latitude",
              "Longitude",
              "Accuracy (m)"
              // Add more if you add more fingerprinting fields
            ];
            // Extract and remove fingerprint attributes
            const fingerprintAttrs = metadata.attributes.filter(attr => fingerprintTraits.includes(attr.trait_type));
            metadata.attributes = metadata.attributes.filter(attr => !fingerprintTraits.includes(attr.trait_type));
            // Prepare plaintext (as JSON)
            const plaintext = JSON.stringify(fingerprintAttrs);
            const encoder = new TextEncoder();
            const plaintextBytes = encoder.encode(plaintext);
            // Encrypt using Reddit Story ID
            const encrypted = await encryptWithStringKey(mandelaAnchor.id, plaintextBytes);
            // Add encrypted attributes to metadata
            metadata.attributes.push(
              { trait_type: "Cyphertext", value: JSON.stringify(encrypted.ciphertext) },
              { trait_type: "IV", value: JSON.stringify(encrypted.iv) },
              { trait_type: "Salt", value: JSON.stringify(encrypted.salt) }
            );
          }
        
          console.log("Data To Be Encoded:", JSON.stringify(metadata, null, 2));   
     
          // Create the payload
          let jsonString = JSON.stringify(metadata, null, 2);
          let compressed = pako.deflate(jsonString);
          let base58 = Base58.encode(compressed);
          let payload = `${window.location.origin}?data=${encodeURIComponent(base58)}`;
          console.log("QR Code Data:", payload);
        
          let imageUrl = null;
          // Replace "ipfs://" with "https://ipfs.io/ipfs/"
          if (metadata.image && metadata.image.startsWith("ipfs://")) {
            imageUrl = metadata.image.replace("ipfs://", "https://ipfs.io/ipfs/");
          }
          console.log("Image URL:", imageUrl);
        
          // Render the QR code with the payload
          function renderQR(dataToUse) {
            const qr = !imageUrl
              ? new QRCodeRenderer(canvas, dataToUse, {
                  margin: 2,
                  color: { dark: "#00FF00", light: "#121212" }
                })
              : new ImageBackgroundQRCodeRenderer(
                  canvas,
                  dataToUse,
                  imageUrl,
                  {
                    margin: 2,
                    color: { dark: "#00FF0077", light: "#00000000" }
                  }
                );
            qr.render(() => {
              canvas.onclick = () => qr.download();
              hideSpinner();
            });
          }
        
          renderQR(payload);
        });
      })();
    }

    window.onload = () => {
      generateQRCode();
    };
  </script>
  <div id="privacy-footer">
    This site personalizes content locally using a short-lived fingerprint.
    <a href="#" id="privacy-link" style="margin-left:6px;text-decoration:underline;">Learn more</a>
    <div id="privacy-tooltip" style="display:none;position:absolute;left:50%;transform:translateX(-50%);bottom:40px;max-width:480px;background:#222;color:#00FF00;padding:22px 22px 14px 22px;border-radius:10px;box-shadow:0 2px 16px #000;font-size:1em;z-index:9999;text-align:left;">
      <h2 style="margin-top:0;font-size:1.2em;">Privacy Policy</h2>
      <p><strong>Effective:</strong> <span id="privacy-today"></span></p>
      <p>
        This site temporarily generates an encrypted browser fingerprint to personalize the visual content you see (such as generating a unique QR code).
        This fingerprint includes information such as your IP address, approximate location, timezone, and device type, but is immediately encrypted using a
        one-time key that is never stored or reused.
      </p>
      <!--
      <p>
        The encrypted fingerprint is uploaded to a public, decentralized storage system (IPFS), but <strong>cannot be decrypted</strong> without internal
        architectural knowledge and a temporary key that is discarded after use. No personal identifiers, cookies, or IP addresses are stored or logged by us.
      </p>
      -->
      <p>
        We do <strong>not track, profile, or identify</strong> you. We do not store any personal data. This fingerprint is used only during your active session,
        is anonymized before publishing, and is not accessible by third parties in any meaningful way.
      </p>
      <p>
        For questions or concerns, please contact the site operator.
      </p>
      <p><small>This notice was generated for informational purposes and reflects the current technical design.</small></p>
    </div>
  </div>
  <script>
    // Show/hide tooltip on click
    const privacyLink = document.getElementById('privacy-link');
    const privacyTooltip = document.getElementById('privacy-tooltip');
    privacyLink.addEventListener('click', function(e) {
      e.preventDefault();
      privacyTooltip.style.display = privacyTooltip.style.display === 'block' ? 'none' : 'block';
    });
    // Hide tooltip when clicking outside
    document.addEventListener('click', function(e) {
      if (!privacyTooltip.contains(e.target) && e.target !== privacyLink) {
        privacyTooltip.style.display = 'none';
      }
    });
    // Set today's date in tooltip
    document.getElementById("privacy-today").textContent = new Date().toISOString().split("T")[0];
  </script>
</body>
</html>
